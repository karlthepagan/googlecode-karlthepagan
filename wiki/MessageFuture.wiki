#summary interface API for message-based libraries to offer their results to Future-based tokens

= Introduction =

Allow external thread to offer completion results to Future objects. This allows non-blocking libraries to interface with the Future API without wasting a thread (as in Jersey's first HTTP client). This also gives programmers comfortable with procedural code a moderately efficient API with which to access asynchronous resources.

= Details =

*goals / use-cases*:

  # integration with message-passing APIs
  # provide an API to return control to the user at the earliest completion during execution of arbitrary set of message responses (i.e. CompletionService? / completion Queue API)
  # allow mixing in callbacks / interceptors which safely modify the tasks being executed based on user preference (allow any thread to modify the user's set of tasks to wait for, for example user is waiting for all messages of type "client disconnect" and user may provide a callback class which filters the results efficiently, allowing separation of concerns between the filtering and the completion handling logic)
  # allow fine-grained task cancelation by outside callers without a Future handle (i.e. by abstracting requests/responses into request id's)
  # provide building-blocks to aggregate futures into a single-user-thread record updating mechanism

= Related and Alternative Works =

  * FutureTask has set() and setException() methods which are suitable for a simple implementation. If you need to allow multiple handlers to produce a result (distributed computing with duplicate jobs) then MessageFuture.offer() will determine which one was submitted without extra encapsulation. The basic impl, LockMessageFuture, for distributed tasks consumes 20 bytes (24 after aligned) whereas FutureTask(Callable) is 64 bytes per instance, and FutureTask(Runnable) is 80 bytes per instance (more on 64-bit arch). MessageFuture also provides methods to override for result-specific completion callbacks and custom cancellation logic.
  * [https://jdk7.dev.java.net/ JDK7 NIO.2] - has changed IoFuture into the baseline Future API, but uses sun.nio.ch.AbstractFuture as the implementation which has attachment capability and connects to an AsynchronousChannel.
  * [http://docs.jboss.org/xnio/latest/api/index.html?org/jboss/xnio/IoFuture.html jboss.org xnio.IoFuture] - provides an io-focused alternative to Future
  * [https://www.limewire.org/fisheye/browse/limecvs/components/common/src/main/java/org/limewire/concurrent Limewire.org ListeningFuture] - provides completion callbacks for Futures
  * [https://dirmi.dev.java.net/nonav/javadoc/org/cojen/dirmi/Completion.html DiRMI Completion] - allows completion queue registration on individual Futures

= Discussions =
  * concurrency-interest threads on the subject of Executor & Future design: [http://cs.oswego.edu/pipermail/concurrency-interest/2009-April/005971.html 1] [http://cs.oswego.edu/pipermail/concurrency-interest/2007-December/004693.html 2] [http://cs.oswego.edu/pipermail/concurrency-interest/2009-May/006117.html 3]